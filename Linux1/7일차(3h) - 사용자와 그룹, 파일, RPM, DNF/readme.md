# 사용자와 그룹
- 리눅스는 다중 사용자 시스템(multi-user system)이다. 즉 1대의 리눅스에 사용자 여러 명이 동시에 접속해서 사용할 수 있는 시스템이다. 
- 리눅스를 설치하면 기본적으로 root라는 이름을 가진 수퍼 유저superuser가 있다. 이 root 사용자는 시스템의 모든 작업을 실행할 수 있는 권한이 있다. 또한 시스템에 접속할 수 있는 사용자를 생성할 수 있는 권한도 있다.

- 그런데 모든 사용자는 혼자서 존재하는 것이 아니라 하나 이상의 그룹에 소속되어 있어야 한다. 예를 들면 회사에서 '홍길동'이라는 직원이 '전산실'과 같은 어느 부서에 소속된 것과 같다고 생각할 수있다.

- 우선 gedit이나 vi 에디터로 "/etc/passwd" 파일을 열면 다음과 같이 된다.

... 사진

- 여러 명의 사용자가 보일 것이다. 제일 위의 root 사용자부터 제일 아래의 바로 위인 tcpdump 사용자까지는 리눅스에서 기본적으로 존재하는 표준 사용자다.

- 지금은 제일 위에 있는 root 사용자와 제일 아래 부분의 설치 직후 생성된 centos 사용자를 보고 의미를 파악해보자.

- 각 행의 의미는 다음과 같다.

```
사용자 이름:암호:사용자 ID:사용자가 소속된 그룹 ID:전체 이름:홈 디렉터리:기본 셸
```

- 제일 아래의 centos 사용자를 살펴보면, 사용자 이름은 centos 암호가 x로 표시되는데 이는 "/etc/shadow" 파일에 비밀번호가 지정되어 있다는 의미다. 그리고 centos의 사용자 id는 1000번이고, centos가 속한 그룹의 id는 1000번이다. 전체 이름도 centos로 사용하며 centos 사용자의 홈 디렉터리는 "/home/centos"이고 로그인 시 제공되는 셸은 /bin/bash다
- root 사용자의 행을 살펴보면 사용자 id와 그룹 id가 0번으로 설정되어 있음을 확인할 수 있다. 이번에는 "/etc/group" 파일을 확인해보자.

... 그림 


- 각 행의 의미는 다음과 같다.

```
그룹이름:비밀번호:그룹 id:그룹에 속한 사용자 이름
```

- 마지막 '그룹에 속한 사용자 이름은 참조로 사용된다. 즉 해당 부분에 아무것도 써 있지 않다고 해서 그룹에 소속된 사용자가 반드시 없다는 뜻은 아니다. 필자의 경우에도 제일 첫 행 root 그룹에는 실제로 root 사용자가 속해 있으나 여기에는 표현되어 있지 않다. 
- 앞서 살펴본 "/etc/passwd" 파일에서는 centos 사용자가 속한 그룹이 1000번으로 표현되었다. 즉 "/etc/group" 파일에서도 centos 그룹의 ID가 1000번이므로 centos 그룹에는 centos 사용자가 속해 있는 것이다. 
- 사용자 및 그룹과 관련된 명령어는 다음과 같은 것들이 있다. 

#### useradd(또는 addUser)

- 새로운 사용자를 추가해준다. 
- 이 명령을 실행하면 "/etc/passwd", "/etc/shadow", "/etc/group" 또는 파일에 새로운 행이 추가된다.
- 사용 예

```
# useradd newuser      -> newuser라는 이름의 사용자 생성
# useradd -u 1111 newuser     -> newuser 사용자를 생성하면서 사용자 ID를 1111로 지정
# useradd -g mygroup newuser     -> newuser 사용자를 생성하면서 mygroup 그룹에 newuser 사용자를 포함시킴(mygroup 그룹을 먼저 만들어놓아야 함)
# useradd -d /newhome newuser     -> newuser 사용자를 생성하면서 홈 디렉토리를 /newhome으로 지정
# useradd -s /bin/csh newuser 사용자를 생성하면서 기본 셀을 /bin/csh로 지정
```

#### passwd

- 사용자의 비밀번호를 지정하거나 변경한다.
- 사용 예 

```
# passwd newuser      -> newuser 사용자의 비밀번호 지정(또는 변경)
```


#### usermod 

- 사용자의 속성을 변경한다. 옵션은 useradd와 동일하다.
- 사용 예

```
# usermod -g root newuser    -> newuser 사용자의 그룹을 root 그룹으로 변경
```

#### userdel
-  사용자를 삭제한다.
- 사용 예 

```
# userdel newuser     -> newuser 사용자 삭제
# userdel -r newuser   -> newuser 사용자를 삭제하면서 홈 디렉토리까지 삭제
```

#### chage 

- 사용자의 암호를 주기적으로 변경하도록 설정한다.
- 사용 예

```
# chage -l newuser           -> newuser 사용자에 설정된 사항 확인
# chage -m 2 newuser       -> newuser 사용자에 설정한 암호를 사용해야 하는 최소 일자(즉, 변경 후 최소 2일은 사용해야 함)
# chage -M 30                 -> newuser 사용자에 설정한 암호를 사용할 수 있는 최대 일자(즉, 변경 후 최대 30일까지 사용할 수 있음)
# chage -E 2026/12/12 newuser      -> newuser 사용자에 설정한 암호가 만료되는 날짜(즉, 2026/12/12까지만 사용할 수 있음)
# chage -W 19 newuser          -> newuser 사용자에 설정한 암호가 만료되기 전에 경고하는 기간. 지정하지 않을 경우 기본값은 7일(즉, 이와 같이 설정하면 암호가 만료되기 10일 전부터 경고 메시지가 나감)
```

#### groups

- 사용자가 소속된 그룹을 보여준다.
- 사용 예

```
# groups     -> 현재 사용자가 소속된 그룹을 보여줌
# group newuser     -> newuser가 소속된 그룹을 보여줌
```

#### groupadd

- 새로운 그룹을 생성한다.
- 사용 예

```
#groupadd newgroup     -> newgroup이라는 그룹을 생성
#groupadd -g 2222 newgroup    -> newgroup이라는 그룹을 생성하면서 그룹 ID를 2222로 지정
```

#### groupmod

- 그룹의 속성을 변경한다.
- 사용 예

```
# groupmod -n mygroup newgroup   -> newgroup 그룹의 이름을  mygroup으로 변경
```

#### groupdel

- 그룹을 삭제한다.
- 사용 예

```
# groupdel newgroup    -> newgroup 그룹 삭제(단, 해당 그룹을 주요 그룹으로 지정한 사용자가 없어야 함)
```

> 사용자는 주요 그룹 1개와 보조 그룹 여러 개에 가입할 수 있다. 일례로 useradd -g main -G sub user 명령은 user1을 생성하면서 main 그룹을 주요 그룹으로, sub 그룹을 보조 그룹으로 가입시킨다.


#### gpasswd

- 그룹의 암호를 설정하거나 그룹 관리를 수행한다.
- 사용 예

```
# gpasswd newgroup    -> newgroup 그룹의 암호 저장
# gpasswd -A newuser newgroup    -> newuser 사용자를 newgroup 그룹의 관리자로 지정
# gpasswd -a user1 newgroup        -> user1을 newgroup 그룹의 사용자로 추가
# gpasswd -d newuser newgroup    -> user1을 newgroup 그룹의 사용자에서 제거
```

## 실습1

### step 0
Server를 처음 설치 상태로 초기화하자

- root 사용자로 접속한다. 
- 바탕 화면의 왼쪽 위 [현재 활동] →[터미널] 을 선택해서 터미널을 연다.

### step 1

새로운 사용자를 만들어보자 (사용자 생성 작업은 root 사용자만 할 수 있다).

- useradd user1 명령을 입력해 user l 사용자를 만들자.

- "tail /etc/passwd" 명령을 입력해 user1 사용자가 추가되었는지 확인한다(tail은 파일의 마지막 10행을 보여주는 명령이다).
	- 제일 마지막 행에 사용자가 추가된 것이 보인다. 사용자 이름은 앞에서 지정한 user1으로 되어 있다. 그리고 암호는 "/etc/shadow" 파일에 지정되어 있다. 3번째 열에서 user1의 ID는 1001 번으로 되어 있는데, 이는 그 앞에 있는 centos의 1000번 다음에 자동으로 1을 더해서 할당된 것이다. 그룹 ID도 1001번으로 지정되어 있다. 
	- 여기서 주의할 점은 그룹 이름이 아닌 그룹 ID가 지정되어 있다는 점이다. 왜 그런지는 잠시 후 다시 살펴보겠다. 사용자의 홈 디렉터리는 기본 설정인 '/home/사용자이름으로 지정되었고, 셸은 기본 설정인 "/bin/bash"로 지정되었다.

- user 사용자는 그룹을 별도로 지정하지 않았다. 우선 "tail -5 /etc/group" 명령을 입력해 그룹을 확인해보자.
	- 제일 마지막 행에 그룹이 추가되었다. 그룹 이름을 보니 사용자 이름과 동일한 user 으로 되어 있으며, 그룹 ID는 자동으로 마지막 그룹 번호인 1000에서 1이 증가한 1001로 생성되었다.
	- 결론적으로 useradd 명령을 실행해 별도의 그룹을 지정하지 않으면, 자동으로 사용자 이름과 동일한 그룹이 생성되고 새로운 사용자는 생성된 그룹에 자동으로 포함된다. 즉 새로 생성된 그룹(여기서는 user1)은 소속된 사용자가 1명인그룹이 된다.

- 많은 사용자를 관리할 때 지금과 같은 방식으로 관리하면 '사용자 이름 = 그룹 이름'이 되어 관리하기불편하다(직원 이름이 '홍길동'인데 직원의 부서 이름도 '홍길동'이면 좀 이상하다). 그래서 사용자를 관리할경우 먼저 그룹을 만들고 사용자를 만든 그룹에 속하도록 생성하는 것이 바람직하다.

#### step 2

그룹을 별도로 생성하고 해당 그룹에 다수의 사용자를 포함시켜 관리해보자.

- 먼저 user 사용자를 삭제한다. 그리고 centosGroup 그룹을 먼저 만든다.

- 새로운 user1, user2 사용자를 만들면서 그룹을 centosGroup 그룹으로 지정해준다.

- "/etc/passwd" 파일을 확인해보니 그룹 ID가 모두 1001로 되어 있다. "/etc/group" 파일에서 1001번은centosGroup임을 알 수 있다.

- "/etc/shadow" 파일을 확인해보면 제일 아래에 user1, user2라는 두 사용자가 추가되었음을 알 수 있다. 그런데 centos의 경우 암호가 코드화되어 들어 있지만, user1 user2는 해당 부분에 '!!'라는 표시만되어 있다. 이는 아직 암호가 지정되어 있지 않다는 의미다.

- user1 사용자와 user2 사용자의 암호를 지정하자. 둘 다 간단하게 '1234'로 입력한다.

> 간단한 암호 입력 시 경고는 나오지만, root 사용자가 암호를 지정해줄 경우에는 간단한 암호도 지정할 수 있다. 단, 일반 사용자가 자신의 암호를 변경할 때는 간단한 암호가 아닌 8글자 이상으로 영어 사전에 등록되지 않은 단어를 사용해야 한다.

- 다시 /etc/shadow 파일을 확인하면 user1과 user2 사용자에 암호가 지정된 것을 알 수 있다. 그런데 재미있는 점은 앞서 두 사용자의 암호를 모두 '1234'로 입력했으나 코드화된 암호는 서로 다르다는것이다. 이는 "/etc/shadow" 파일을 살펴보더라도 암호를 알 수 없다는 것을 의미한다.

- 이번에는 userl 사용자의 홈 디렉터리인 "/home/user1"과 "/etc/skel" 디렉터리를 비교해보자. 두 디렉터리에 동일한 파일이 들어 있을 것이다. 즉 새로운 사용자를 생성하면 해당 사용자의 홈 디렉터리 기본 설정은 '/home/사용자이름'으로 지정되며, "/etc/skel" 디렉터리의 모든 내용을 사용자의 홈 디렉터리에 복사하는 작업이 발생한다. 그러므로 앞으로 생성하는 사용자에게 특정한 파일 등을 배포하고 싶은 경우 "/etc/skel" 디렉터리에 넣어두면 된다.

> 이름에서 예측할 수 있듯이 '/skel' 디렉터리는 skeleton (뼈대)의 약자다.


#### step 3
- 연습한 사용자 및 그룹을 삭제한다.

```
# userdel -r user1
# userdel -r user2
groupdel centosGroup
```

# 파일과 디렉토리의 소유권과 허가권

- 리눅스는 각각의 파일과 디렉터리마다 소유권과 허가권이라는 속성이 있다. root 사용자가 자신의 홈 디렉터리에서 <b>touch sample.txt</b> 명령을 실행해 빈 파일을 만들고 <b>Is -I</b> 명령을 실행하면 다음과 같이 나타날 것이다.

- 방금 생성한 sample.txt 파일 정보를 다음과 같이 간략히 나타냈다.

- 표시된 정보의 의미를 각 항목별로 확인해보자.

### 파일 유형

- 파일이 어떤 종류인지 나타낸다. 디렉터리인 경우 'd'가 일반적인 파일인 경우 '-'가 표시된다. 그 외에 b(블록 디바이스), c(문자 디바이스), |(링크) 등이 있다.


> 'b'나'c'는 디바이스(장치)를 뜻한다. <b>Is -I /dev | more</b> 명령을 실행해서 확인해보면 b나 c가 많이 보일 것이다. b는 블록디바이스(Block Device)를 의미하며 대표적인 것으로 하드디스크 플로피 디스크 CD/DVD 등의 저장장치가 있다. c는 문자 디비이스(Character Device)를 의미하며 대표적인 것으로 마우스, 키보드 프린터 등의 입출력장치가 있다. 또 |은 링크(Link)를 뜻한다. 링크란 Windows의 '바로가기 아이콘'과 비슷한 개념으로 연결된 파일을 의미한다. 이때 실제 파일은 다른 곳에 존재한다는 것을 기억하자.

### 파일 허가권

- 파일 허가권(pemission)은 rw-, r--, r-- 3개씩 끊어서 인식하면 된다. r은 read, w는 write, x는 execute의 약자다. 즉 rw-는 읽거나 쓸 수 있지만 실행할 수는 없다는 의미며 rwx로 표시되면 읽고, 쓰고, 실행이 가능한 파일이라는 의미다.

- 또한 첫 번째 rw-는 소유자(user)의 파일 접근 권한을 두 번째 r--는 그룹(group)의 파일 접근 권한을, 세 번째 r--는 그 외 사용자(other)의 파일 접근 권한을 의미한다. 풀어서 얘기하면 sample.txt 파일의 소유자는 읽거나 쓸 수 있고 그룹은 읽을 수만 있으며 그 외 사용자도 읽을 수만 있도록 허가되어 있다는 의미다.

- sample.txt 파일의 허가권을 다음과 같이 숫자로도 표현할 수 있다.

- 소유자의 허가권인 이라는 숫자는 2진수 110 이므로 rw-로 표현할 수 있고, 그룹의 허가권인 4 라는 숫자는 2진수 100이므로 r--로, 그 외 사용자의 허가권인 4 라는 숫자도 2진수로 100이므로 r--로 표현되는 것이다. 몇 가지 예를 들면, 파일 허가권이 754 라는 것은 rwxr-xr--가 되므로 소유자는 읽고/쓰고/실행할 수 있고, 그룹은 읽고/실행할 수만 있으며 그 외 사용자는 읽을 수만 있다는 것을 의미한다. 참고로 <b>디렉터리 (=폴더)의 경우 해당 디렉터리로 이동하려면 반드시 실행 (x)권한이 있어야 한다. 그래서 디렉터리는 일반적으로 소유자/그룹/기타 사용자 모두에게 실행 (x) 권한이 설정되어 있을 것이다.</b>

#### 파일 확장명

- Windows의 경우 \*.exe는 실행 파일, \*.txt는 텍스트 파일 등과 같이 확장명으로 해당 파일의 종류를 판단하지만, <b>리눅스는 확장자에 별 의미를 두지 않는다.</b> 즉 실행 파일이든 텍스트 파일이든 모두 일반적으로 확장명을 갖지 않으며, 확장명을 갖더라도 편리함을 위해서일 뿐 확장명이 파일의 종류를 판단하는 절대적인 의미는 아니다. 그래서 해당 파일이 어떤 파일인지 알려면 file 명령을 사용해야 한다.

- 파일의 허가권을 변경하는 명령어로 chmod 명령이 있다. 이 명령어는 root 사용자 또는 해당 파일의 소유자만 실행할 수 있다. 일례로 chmod 777 sample.txt 명령을 실행하면 sample.txt 파일은 모든 사용자가 읽고 쓰고, 실행할 수 있는 파일이 된다.

> 파일의 허가권을 실행할 수 있도록 설정되어 있어도, 파일이 실제로 실행 가능한 코드가 아니라면 실행 시 오류가 발생할 것이다. Windows에서 그림 파일인 mypic.jpg 파일을 실행 파일인 mypic.exe로 확장명을 변경할 수 있지만, mypic.exe가 실제로 실행되지 않는 것과 같은 이치다.

- chmod 명령을 상대 모드(symbolic method)로도 사용할 수 있다. <b>chmod u+x 파일이름</b> 명령은 '소유자(User)에게 실행 execute 권한을 허가하라 (+)'는 의미다. 몇 가지 예를 들면, u-wx는 사용자에게 쓰기와 실행 권한을 제거하라는 의미며, g+rx는 그룹에게 읽기와 실행 권한을 허가하라는 의미고, o+rwx는 그 외 사용자에게 읽기/쓰기/실행 권한을 허가하라는 의미다.


### 파일 소유권

- 파일 소유권(ownership)은 파일을 소유한 사용자와 그룹을 의미한다. sample.txt 파일은 root라는 이름의 사용자가 소유자며, 그룹도 root로 되어 있다. 파일의 소유권을 바꾸는 명령어는 chown이다. 사용법은 <b>chown 새로운사용자이름(.새로운그룹이름) 파일이름</b> 명령의 형식으로 사용하면 된다. 예를 들어 <b>chown centos sample.txt</b> 명령은 sample.txt 파일의 소유자를 centos 사용자로 바꾸라는 의미고, <b>chown centos.centos sample.txt</b> 명령은 파일의 그룹도 centos 그룹으로 바꾸라는 의미다. 또한 <b>chgrp centos sample.txt</b> 명령은 그룹만 centos 그룹으로 변경하라는 의미다.


## 실습2

파일의 허가권 및 소유권을 확실히 이해하자.

### step 0

Server를 실행해 root 사용자로 접속한다.

- 터미널을 열고 연습용 파일을 하나 생성하자. <b>vi test</b> 명령을 입력한 후 "I" 또는 "A"를 눌러 다음 내용을 쓴 다음 ':wq'를 입력해 내용을 저장하고 vi 에디터를 종료한다. 아직 vi 에디터에 익숙하지 않다면 gedit test 명령을 입력해 gedit을 사용해도 관계없다 (한/영 전환은 [shift] + Space bar)다).

```
안녕하세요? 그냥 연습 파일입니다.
ls /car
```

- Is -I test 명령를 입력해 파일의 속성을 확인하자.

- 이 파일은 허가권이 rw-r--r--로 설정되어 있고 소유자는 root 사용자이며 그룹은 root 그룹으로 되어있다. 즉 root 사용자는 이 파일을 rw- (읽고, 쓰고) 할 수 있고 x (실행) 할 수 없다. 또 root 그룹 및 그 외 사용자는 r-- (읽기)만 가능하다.

### step 1

파일의 속성을 변경해보자.

- test 파일을 실행한다. 

```
whoami   -> 현재 사용자가 누구인지 알려줌
./test       -> 현재 디렉토리의 test 파일 실행('./'는 현재 디렉토리에 있는 파일을 의미함)
```
	- 허가가 거부되었다는 메시지가 나왔다. 현재 사용자인 root의 실행 권한이 rw--이므로 실행할 수 없기 때문이다.

- 이 파일을 실행할 수 있도록 rwxr-xr-x (755)로 변경하기 위해 <b>chmod 755 test</b> 명령을 입력한다. 그리고 <b>Is -I test</b> 명령을 입력해 test 파일의 변경 사항이 있는지 확인한다. 마지막으로 <b>./test</b> 명령을 입력해 다시 파일을 실행해본다.

### step 2

이번에는 소유권을 변경해보자.

- 먼저 chown centos test 명령을 입력해 test 파일의 소유권을 centos 사용자로 변경한다.

- chgrpcentos test 명령을 입력해 그룹도 centos 그룹으로 변경한다.
	- 사용자와 그룹을 한꺼번에 바꾸려면 chown centos.centos test 또는 chown centos:centos test 명령을 입력한다.

- 이제는 centos 사용자로 접속한 후 test 파일의 속성을 모두 읽기/쓰기/실행(777)할 수 있도록 변경한다.

```
su - centos    -> centos 사용자로 접속(root)가 접속할 경우 암호를 물어보지 않음)
pwd             -> 현재 디렉토리의 확인. 사용자 홈 디렉토리가 나올 것임
ls -l /root/test
ls -ld /root    -> /root 디렉토리의 속성 확인

```

- 그런데 앞에서 test 파일의 소유권을 centos에게 확실히 넘겨줬는데도 centos 사용자는 "/root/test" 디렉터리 접근이 거부되었다. 그 이유는 "/root" 디렉터리의 속성이 r-xr-x---로 되어 있기 때문이다. 마지막 '---'가 기타 사용자의 허가권인데, 아무런 읽기/쓰기/실행 권한이 허가되지 않았으므로 centos 사용자는 '/root' 디렉터리의 접근이 거부된 것이다. 그래서 '/root' 디렉터리 안에 있는 test 파일의 소유가 centos 사용자에게 있더라도 사용할 수 없다.

- 우선 다시 root 사용자로 test 파일을 "/home/centos" 디렉터리로 옮긴 후 다시 허가권을 변경한다.

```
exit       -> 다시 원래 접속한 사용자(이 경우에는 root)로 돌아감
mv test -centos    -> -centos는 centos 사용자의 홈 디렉토리(/home/centos와 동일)
su - centos
ls -l test
chmod 777 test
ls -l test
```
	- 별 이상 없이 잘 실행되었다.


- 이번에는 <b>chown root.root test</b> 명령을 입력해 test의 소유권을 다시 root 사용자에게 돌려준다.
	- 그런데 명령을 허용하지 않는다는 메시지가 나온다. 정상적인 상황이다. 만약 이 test 파일이 심각한 바이러스 파일이고 지금 명령이 실행되었다면 centos 사용자가 마음대로 root 사용자에게 바이러스 파일을 전달하게 되는 것이다. 그러므로 파일의 소유권을 바꾸는 chown 명령은 root 사용자만 실행할 수 있다. 

- exit 명령을 입력해 다시 root 사용자로 돌아온다.


#### 특수한 형태의 파일 권한

- 파일의 허가권은 앞에서 배운 rwx 외에도 특수한 용도의 setuid, setgid, stiky bit가 있다. 앞에서는 파일의 허가권을 주로 8진수 000~777 로 3자리만 표현했으나, 실제로는 8진수 0000~0777까지 4자리로 표현할 수 있다. 첫 번째 자리의 8진수를 2진수로 표현하면 1002(=4), 0102(=2), 0012(=1), 000z(=0) 네 가지중 하나가 올 수 있는데, 지금까지는 모두 2진수 0002로 취급하고 언급했던 것이다.

- setuid bit
	- 8진수 네 자리 중 첫 번째 값을 1002(=4)로 표현하는 것을 setuid 부르는데, 리눅스의 파일 중 비밀번호를 지정하는 "/bin/passwd"가 이에 해당한다. "/bin/passwd" 파일의 속성을 확인하면 다음과 같이 표시된다.	<br> <b>-rwsr-xr-x. 1 root root 27880 8월 4 16:44 /bin/passwd</b>
	
	- 이 파일은 root의 소유이므로 원칙적으로는 root만 접근할 수 있으나, 47558(=rwsr-xr-x)로 설정되었기 때문에 일반 사용자도 실행할 수 있다. 단, 실행하는 순간에 root의 권한을 잠깐 빌려와서 사용하는 효과를 갖는다. passwd 명령의 경우 root가 모든 사용자의 비밀번호를 변경할 수 있다는 점은 기억하고 있을 것이다. 하지만 일반 사용자도 passwd 명령으로 자신의 비밀번호는 변경할 수 있었다. 그 이유가 이 파일이 setuid로 설정되어 있기 때문이다. setuid로 설정하려면 <b>chmod u+s 파일명</b> 명령을 사용한다. 하지만 특별한 경우가 아니라면 사용자의 파일을 setuid bit로 설정하는 것은 보안상 바람직하지 않다.

- setgid bit
	- 8진수 네 자리 중 첫 번째 값을 010>(=2)로 표현하는 것을 setgid라 부르는데, setuid bit와 작동 개념이 비슷하다. 단, 사용자가 아닌 그룹에 대해서 적용된다고 보면 된다.
	
- stiky bit
	- 8진수 네 자리 중 첫 번째 값을 0012(=1)로 표현하는 것을 stiky bit라 부른다. stiky bit는 여러 사람이 공유할 디렉터리에 주로 설정되는데, stiky bit로 설정된 디렉터리 안에서는 모든 사용자가 파일/디렉터리를 생성해 사용할 수 있지만, 다른 사용자의 파일을 삭제하지는 못한다. stiky bit로 설정한 디렉터리는 회사에서 업무상 공유할 내용들을 업로드시키는 목적으로 주로 사용된다. stiky bit로 설정하려면 <b>chmod o+t 파일명</b> 등의 명령을 사용한다.


### 링크

- 파일의 링크(Link)는 <b>하드 링크 Hard Link와 심볼릭 링크(symbolic Link)</b> 2가지가 있다. 아래 그림을 보면, 원본 파일이 inode1을 사용할 때 하드 링크를 생성하면 '하드 링크 파일'만 하나 생성되며 같은 inode1을 사용하게 된다. 하드 링크를 생성하려면 <b>In 링크대상파일이름 링크파일이름</b> 명령을 실행한다.

#### inode

- inode는 리눅스/유닉스의 파일 시스템에서 사용하는 자료구조를 말하는데, 파일이나 디렉터리의 여러 가지 정보가 있다. 모든 파일이나 디렉터리는 각자 1개씩의 inode가 있으며 각 inode에는 해당 파일의 소유권 허기권, 파일 종류 등의 정보와 해당 파일의 실제 데이터 위치(주소)도 있다. 이러한 inode가 모여 있는 공간이 inode 블록이며 일반적으로 전체 디스크 공간의 1% 정도 차지한다. Data 블록은 실제 데이터가 저장된 디스크 공간으로 전체 디스크의 대부분을 차지한다.

- 원본 파일에 심볼릭 링크를 생성하면 새로운 inode2를 만들고, 데이터는 원본 파일과 연결되는 효과를 갖는다. 일반적으로 사용자는 주로 심볼릭 링크를 사용하며, Windows의 바로 가기 아이콘도 심볼릭 링크에 해당된다. 심볼릭 링크를 생성하려면 <b>In -s 링크대상파일이름 링크파일이름</b> 명령을 실행한다. 개념이 잘 이해되지 않는다면 실습을 통해 이해해보자.

#### 하드 링크와 심볼릭 링크의 비교


## 실습3

하드 링크와 심볼릭 링크를 생성해보자. 위 그림을 참고하면서 진행한다. 

### step 0

- Server를 실행하자.

### step 1

- "/root/linktest" 디렉터리를 만들고 그 안에 basefile이란 파일을 만들자. 그리고 vi 에디터나 gedit을 이용해 “파일 링크를 실습하기 위한 원본 파일입니다."를 입력하고 저장한 후 cat 명령을 사용해 파일 내용을 확인하자.

### step 2

하드 링크와 심볼릭 링크를 확인해보자.

-  In 명령어와 옵션을 조합해 하드 링크 및 심볼릭 링크 파일을 만들자

```
ln basefile hardfile   -> 하드 링크 생성
ln -s basefile softlink  -> 심볼릭 링크(=소프트 링크) 생성
ls -il  -> -il 옵션은 inode 번호를 제일 앞에 출력
cat hardlink   -> 하드 링크의 내용 확인
cat softlink    -> 소프트 링크의 내용 확인
```

	- 앞에 나온 그림 보면서 결과 창을 확인하자. 
	- 원본 파일(basefile)은 inode가 inodel(1573326번)으로 지정되어 있다. 그리고 하드 링크 파일(hardlink)도 그림과 마찬가지로 inodel(1573326번)으로 지정되어 있다. 
	- 그러나 심볼릭 링크 파일(softlink)은 inode2(1573324번)로 다르게 지정되어 있다. 
	- 원본 파일(basefile)과 하드 링크 파일(hardlink)은 Data 블록에 같은 원본 파일 데이터를 사용하므로 크기가 61바이트로 동일하며, 심볼릭 링크 파일(softlink)은 별도의 원본 파일 포인터를 갖기 때문에 8바이트로 크기가 다르다.
	
	- 파일 이름에서도 심볼릭 링크 파일 (softlink)은 원본 파일 (basefile)을 지정한다는 의미로 화살표(→)가 표시되어 있다.
	
- 원본 파일 (basefile)을 다른 곳으로 이동시키고 하드 링크 파일(hardlink)과 심볼릭 링크 파일(softlink)을 확인해보자.

```
mv basefile ../     -> basefile을 앞 디렉토리(..)로 이동
ls -il
 car hardlink
 cat softlink
```
	
	- 결과를 보면 하드링크는 디렉토리 원본 파일이 없어져도 아무 이상이 없고, 심볼릭 링크는 디렉토리에서 원본파일이 없어지면 연결이 끊어진다.

- 원본 파일을 현재 디렉토리로 가져와서 다시 한 번 확인해보면 심볼릭 링크가 원상태로 복구되었음을 확인할 수 있다.


 