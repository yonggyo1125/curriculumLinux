# 파이프, 필터 리디렉션

#### 파이프
- 파이프(pipe)란 2개의 프로그램을 연결하는 연결 통로의 의미다.
- 'ㅣ'를 사용한다 ([Shift] + \\ 를 누른 글자).
- 사용 예

```
# ls -l /etc | more  
		-> 'ls -1 /etc'를 입력하면 파일이 너무 많아서 
            1페이지에모두 담을 수 없으므로 1페이지씩 나눠서 보겠다는 의미다.
```

#### 필터
- 필터(filter)란 필요한 것만 걸러주는 명령어다. 
- <b>grep, tail, wc, sort, awk, sed</b> 명령어 등이 있다. 주로 파이프와 같이 사용된다.
- 사용 예

```
# ps -ef | grep bash     
            -> ps -ef 명령을 입력하면 모든 프로세스 번호를 출력하므로, 
			    bash라는 글자가 들어간 프로세스만 출력하게 한다.
				
# rpm -qa | grep dnf 
            -> 설치된 패키지 중에서 dnf라는 글자가 들어간 패키지를 출력한다. 
			    그냥 rpm -qa dnf 명령을 실행하면 dnf출력되지 않는다.
```

#### 리디렉션

- 리디렉션(redirection)은 표준 입출력의 방향을 바꿔준다.
- 표준 입력은 키보드, 표준 출력은 모니터지만 이를 파일로 처리하고 싶을 때 주로 사용한다.
- 사용 예

```
# ls -l > list.txt    
            -> Is I 명령 결과를 화면에 출력하지 않고 list.txt 파일에 저장하도록 한다. 
			    만약 list.txt 파일이 기존에 있다면 덮어쓴다(overwrite).
				
# ls -l >> list.txt
            -> 위와 같다. 단 list.txt 파일이 기존에 있다면 기존 내용에 이어서(append) 쓴다.
			
# sort < list.txt   
            -> list.txt 파일을 정렬해서 화면에 출력한다

# sort < list.txt > out.txt  
            -> list.txt 파일을 정렬해서 out.txt 파일에 쓴다.
```

* * * 
# 프로세스, 데몬, 서비스

## 프로세스

- 프로세스(Process)를 정의하면 '하드디스크에 저장된 실행 코드 (프로그램)가 메모리에 로딩되어 활성화된 것' 정도로 설명할 수 있다.

- 예를 들어 웹 브라우저 프로그램인 Firefox는 하드디스크 어딘가에 저장되어 있을 것이다. 이렇게 하드에 저장된 파일을 '프로그램'이라고 부르며, Firefox를 <b>실행해서 화면에 나타난 상태 (더 정확히는 메모리에 로딩된 상태)를 '프로세스'라고 부른다.</b>

- 프로세스와 관련된 필수 개념 및 용어는 다음과 같다.

### 포그라운드 프로세스

- 포그라운드 프로세스(Foreground Process)는 방금 얘기한 Firefox 등과 같이, <b>실행하면 화면에 나타나서 사용자와 상호 작용하는 프로세스를 말한다.</b> 화면에서 실행되는 것이 보이는 프로세스라고 생각하면 된다.

### 백그라운드 프로세스

- 백그라운드 프로세스(Background Process) 는 실행은 되었지만 <b>화면에 나타나지 않고 뒤에서 실행되는 프로세스를 말한다.</b> 예를 들어 바이러스 백신, 서버 데몬 등은 눈에 보이지 않지만 실행된다.

### 프로세스 번호

- 메모리에 로딩되어 활성화된 프로세스를 구분하려면 각각의 고유 번호가 필요하다. 이렇게 각각의 프로세스에 할당된 고유 번호를 프로세스 번호라고 한다. 
- 프로세스 번호가 필요한 이유는, 활성화된 프로세스를 메모리에서 강제로 제거하려면 프로세스 번호를 사용해야 하기 때문이다.

### 작업 번호

- 현재 실행되는 백그라운드 프로세스의 순차 번호를 의미한다.


### 부모 프로세스와 자식 프로세스

- 모든 프로세스는 혼자서 독립적으로 실행되는 것이 아니라 부모 프로세스의 하위에 종속되어 실행된다. 
- 예를 들어 Firefox 같은 경우 X 윈도 프로세스가 구동된 상태에서 실행되어야 하므로, X 윈도는 Firefox의 부모 프로세스이며 Firefox는 X 윈도의 자식 프로세스라고 부른다. 
- 여기서 Firefox를 그냥 두고 X 윈도만 강제 종료하면 Firefox가 계속 실행될까? 당연히 Firefox도 종료된다. 즉 부모 프로세스를 종료하면 그에 종속된 자식 프로세스도 모두 종료되는 것이다.


## 프로세스와 관련된 주요 명령

### ps

- 현재 프로세스의 상태를 확인하는 명령어로, 많은 옵션과 함께 사용할 수 있다. 
- 프로세스의 번호 및 상태를 확인할 때는 <b>ps -ef | grep 프로세스이름</b> 명령을 사용한다.

### kill

- 프로세스를 강제로 종료하는 명령어로, -9 옵션과 함께 사용하면 무조건 프로세스가 종료된다. 
- 예를 들어 응답하지 않고 무한 루프를 도는 프로세스는 <b>kill -9 프로세스번호</b> 명령을 실행해 강제 종료시키면 된다.

### pstree

- 부모 프로세스와 자식 프로세스의 관계를 트리 형태로 보여준다.

## 실습1

포그라운드 프로세스와 백그라운드 프로세스를 살펴보자.

#### step0 

- Server를 실행한다.

#### step1

무한 루프를 도는 프로세스를 중지해보자.

- 터미널에서 <b>yes \> /dev/null</b> 명령을 입력해 무한루프를 도는 단순한 프로세스를 생성하자.

> <b>yes</b> 명령은 단순히 yes라는 글자를 화면에 무한출력한다. /dev/null 은 아무것도 아닌(아무 반응도 하지 않는) 장치를 말한다.

- 터미널 메뉴의 [파일] → [새창]을 선택해서 터미널을 하나 더 열고 <b<ps -ef | grep yes</b> 명령으로 프로세스 번호를 확인한다. 다음을 살펴보면 제일 앞에 나오는 root는 프로세스의 소유주고 그 다음 6559은 프로세스 번호며 그다음 2670는 부모 프로세스 번호다. 프로세스 번호를 확인했다면 <b>kill -9 6559</b> 명령을 입력해 프로세스를 종료한다.

> <b>ps -ef | grep 프로세스이름</b> 명령의 결과 중에서 'grep --color=auto yes'라는 글자가 들어간 행은 무시한다.


